{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/p5-bbox-aligned-text/lib/bbox-aligned-text.js","main.js","src/js/generators/noise-generators.js","src/js/generators/sin-generator.js","src/js/main.js","src/js/particles/fleeing-particle.js","src/js/particles/text-particle.js","src/js/sketches/fleeing-halftones.js","src/js/sketches/halftone-flashlight-word.js","src/js/sketches/noisy-word.js","src/js/sketches/word-particle-wrapping.js","src/js/utilities/dom-utilities.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","BboxAlignedText","font","text","fontSize","pInstance","this","_font","_text","_fontSize","undefined","p","window","_rotation","_hAlign","ALIGN","BOX_CENTER","_vAlign","BASELINE","_calculateMetrics","BOX_LEFT","BOX_RIGHT","BOX_TOP","BOX_BOTTOM","FONT_CENTER","ALPHABETIC","prototype","setText","string","setTextSize","setRotation","angle","setAnchor","hAlign","vAlign","CENTER","getBbox","x","y","pos","_calculateAlignedCoords","_boundsOffset","w","width","h","height","draw","drawBounds","push","_calculateRotatedCoords","rotate","textAlign","LEFT","textFont","textSize","stroke","boundsX","boundsY","noFill","rect","pop","rx","Math","cos","PI","ry","sin","newX","newY","halfWidth","console","log","_distBaseToMid","_distBaseToBottom","_descent","_ascent","shouldUpdateHeight","bounds","textBounds","_textAscent","_textDescent","halfHeight","abs","2","NoiseGenerator1D","min","max","increment","offset","position","random","NoiseGenerator2D","xMin","xMax","yMin","yMax","xIncrement","yIncrement","xOffset","yOffset","xNoise","yNoise","setBounds","setIncrement","generate","_update","noise","map","options","3","SinGenerator","angleIncrement","startingAngle","4","./sketches/fleeing-halftones.js","./sketches/halftone-flashlight-word.js","./sketches/noisy-word.js","./sketches/word-particle-wrapping.js","5","FleeingParticle","color","radius","velocity","_pos","copy","_initPos","_vel","_color","_radius","_noiseGenerator","Noise","_maxVelocity","_xMax","_xMin","_yMax","_yMin","headTowardsInitial","dx","dy","dist","sqrt","atan2","noiseMax","TWO_PI","avoid","update","add","_isOffscreen","fill","noStroke","ellipse","../generators/noise-generators.js","6","TextParticle","_bboxText","BboxText","_wrappedPos","_xReflectPos","_yReflectPos","setVelocity","radians","amountOffscreen","distBeyondWrap","left","right","top","bottom","equals","p5-bbox-aligned-text","7","startSketch","id","sketchesContainer","document","getElementById","dom","createElement","p5","_p","preload","setup","loadFont","fontPath","renderer","createCanvas","canvasSize","canvas","addEventListener","isMouseOver","background","bboxText","bbox","startX","floor","endX","ceil","startY","endY","spacing","loadPixels","pixelDensity","circles","jitter","bind","particleRadius","pixels","g","b","c","saturation","createVector","vel","randomVelocity","col","rad","particle","particles","updatePixels","magnitude","isFirstFrame","blendMode","BLEND","MULTIPLY","mouseX","mouseY","fontsFolder","../particles/fleeing-particle.js","../utilities/dom-utilities.js","8","circle","9","strokeWeight","rotationNoise","xyNoise","rotation","xyOffset","translate","10","textParticle","rotationGenerator","directionGenerator","../generators/sin-generator.js","../particles/text-particle.js","11","forEachInObject","object","iterationFunction","key","hasOwnProperty","tagName","parameters","parent","el","textContent","className","style","addStyle","attributes","addAttributes","appendChild","element","val","removeElement","parentElement","removeChild"],"mappings":"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","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = BboxAlignedText;\r\n\r\n/**\r\n * Creates a new BboxAlignedText object - a text object that can be drawn with\r\n * anchor points based on a tight bounding box around the text.\r\n * @constructor\r\n * @param {object} font               p5.Font object\r\n * @param {string} text               String to display\r\n * @param {number} [fontSize=12]      Font size to use for string\r\n * @param {object} [pInstance=window] Reference to p5 instance, leave blank if\r\n *                                    sketch is global\r\n * @example\r\n * var font, bboxText;\r\n * function preload() {\r\n *     font = loadFont(\"./assets/Regular.ttf\");\r\n * }\r\n * function setup() {\r\n *     createCanvas(400, 600);\r\n *     background(0);\r\n *     \r\n *     bboxText = new BboxAlignedText(font, \"Hey!\", 30);    \r\n *     bboxText.setRotation(PI / 4);\r\n *     bboxText.setAnchor(BboxAlignedText.ALIGN.BOX_CENTER, \r\n *                        BboxAlignedText.BASELINE.BOX_CENTER);\r\n *     \r\n *     fill(\"#00A8EA\");\r\n *     noStroke();\r\n *     bboxText.draw(width / 2, height / 2, true);\r\n * }\r\n */\r\nfunction BboxAlignedText(font, text, fontSize, pInstance) {\r\n    this._font = font;\r\n    this._text = text;\r\n    this._fontSize = (fontSize !== undefined) ? fontSize : 12;\r\n    this.p = pInstance || window; // If instance is omitted, assume global scope\r\n    this._rotation = 0;\r\n    this._hAlign = BboxAlignedText.ALIGN.BOX_CENTER;\r\n    this._vAlign = BboxAlignedText.BASELINE.BOX_CENTER;\r\n    this._calculateMetrics(true);\r\n}\r\n\r\n/**\r\n * Vertical alignment values\r\n * @public\r\n * @static\r\n * @readonly\r\n * @enum {string}\r\n */\r\nBboxAlignedText.ALIGN = {\r\n    /** Draw from the left of the bbox */\r\n    BOX_LEFT: \"box_left\",\r\n    /** Draw from the center of the bbox */\r\n    BOX_CENTER: \"box_center\",\r\n    /** Draw from the right of the bbox */\r\n    BOX_RIGHT: \"box_right\"\r\n};\r\n\r\n/**\r\n * Baseline alignment values\r\n * @public\r\n * @static\r\n * @readonly\r\n * @enum {string}\r\n */\r\nBboxAlignedText.BASELINE = {\r\n    /** Draw from the top of the bbox */\r\n    BOX_TOP: \"box_top\",\r\n    /** Draw from the center of the bbox */\r\n    BOX_CENTER: \"box_center\",\r\n    /** Draw from the bottom of the bbox */\r\n    BOX_BOTTOM: \"box_bottom\",\r\n    /** \r\n     * Draw from half the height of the font. Specifically the height is\r\n     * calculated as: ascent + descent.\r\n     */\r\n    FONT_CENTER: \"font_center\",\r\n    /** Draw from the the normal font baseline */\r\n    ALPHABETIC: \"alphabetic\"\r\n};\r\n\r\n/**\r\n * Set current text\r\n * @public\r\n * @param {string} string Text string to display\r\n */\r\nBboxAlignedText.prototype.setText = function(string) {\r\n    this._text = string;\r\n    this._calculateMetrics(false);\r\n};\r\n\r\n/**\r\n * Set current text size\r\n * @public\r\n * @param {number} fontSize Text size\r\n */\r\nBboxAlignedText.prototype.setTextSize = function(fontSize) {\r\n    this._fontSize = fontSize;\r\n    this._calculateMetrics(true);\r\n};\r\n\r\n/**\r\n * Set rotation of text\r\n * @public\r\n * @param {number} angle Rotation in radians\r\n */\r\nBboxAlignedText.prototype.setRotation = function(angle) {\r\n    this._rotation = angle;\r\n};\r\n\r\n/**\r\n * Set anchor point for text (horizonal and vertical alignment) relative to\r\n * bounding box\r\n * @public\r\n * @param {string} [hAlign=CENTER] Horizonal alignment\r\n * @param {string} [vAlign=CENTER] Vertical baseline\r\n */\r\nBboxAlignedText.prototype.setAnchor = function(hAlign, vAlign) {\r\n    this._hAlign = hAlign || BboxAlignedText.ALIGN.CENTER;\r\n    this._vAlign = vAlign || BboxAlignedText.BASELINE.CENTER;\r\n};\r\n\r\n/**\r\n * Get the bounding box when the text is placed at the specified coordinates.\r\n * Note: this is the unrotated bounding box!\r\n * @param  {number} x X coordinate\r\n * @param  {number} y Y coordinate\r\n * @return {object}   Returns an object with properties: x, y, w, h\r\n */\r\nBboxAlignedText.prototype.getBbox = function(x, y) {\r\n    var pos = this._calculateAlignedCoords(x, y);\r\n    return {\r\n        x: pos.x + this._boundsOffset.x,\r\n        y: pos.y + this._boundsOffset.y,\r\n        w: this.width,\r\n        h: this.height\r\n    };\r\n};\r\n\r\n/**\r\n * Draws the text particle with the specified style parameters. Note: this is\r\n * going to set the textFont, textSize & rotation before drawing. You should set\r\n * the color/stroke/fill that you want before drawing. This function will clean\r\n * up after itself and reset styling back to what it was before it was called.\r\n * @public\r\n * @param  {number}  [x=0]              X coordinate of text anchor\r\n * @param  {number}  [y=0]              Y coordinate of text anchor\r\n * @param  {boolean} [drawBounds=false] Flag for drawing bounding box\r\n */\r\nBboxAlignedText.prototype.draw = function(x, y, drawBounds) {\r\n    drawBounds = drawBounds || false;\r\n    var pos = {\r\n        x: (x !== undefined) ? x : 0, \r\n        y: (y !== undefined) ? y : 0\r\n    };\r\n\r\n    this.p.push();\r\n\r\n        if (this._rotation) {\r\n            pos = this._calculateRotatedCoords(pos.x, pos.y, this._rotation);\r\n            this.p.rotate(this._rotation);\r\n        }\r\n\r\n        pos = this._calculateAlignedCoords(pos.x, pos.y);\r\n\r\n        this.p.textAlign(this.p.LEFT, this.p.BASELINE);\r\n        this.p.textFont(this._font);\r\n        this.p.textSize(this._fontSize);\r\n        this.p.text(this._text, pos.x, pos.y);\r\n\r\n        if (drawBounds) {\r\n            this.p.stroke(200);\r\n            var boundsX = pos.x + this._boundsOffset.x;\r\n            var boundsY = pos.y + this._boundsOffset.y;\r\n            this.p.noFill();\r\n            this.p.rect(boundsX, boundsY, this.width, this.height);            \r\n        }\r\n\r\n    this.p.pop();\r\n};\r\n\r\n/**\r\n * Project the coordinates (x, y) into a rotated coordinate system\r\n * @private\r\n * @param  {number} x     X coordinate (in unrotated space)\r\n * @param  {number} y     Y coordinate (in unrotated space)\r\n * @param  {number} angle Radians of rotation to apply\r\n * @return {object}       Object with x & y properties\r\n */\r\nBboxAlignedText.prototype._calculateRotatedCoords = function (x, y, angle) {  \r\n    var rx = Math.cos(angle) * x + Math.cos(Math.PI / 2 - angle) * y;\r\n    var ry = -Math.sin(angle) * x + Math.sin(Math.PI / 2 - angle) * y;\r\n    return {x: rx, y: ry};\r\n};\r\n\r\n/**\r\n * Calculates draw coordinates for the text, aligning based on the bounding box.\r\n * The text is eventually drawn with canvas alignment set to left & baseline, so\r\n * this function takes a desired pos & alignment and returns the appropriate\r\n * coordinates for the left & baseline.\r\n * @private\r\n * @param  {number} x      X coordinate\r\n * @param  {number} y      Y coordinate\r\n * @return {object}        Object with x & y properties\r\n */\r\nBboxAlignedText.prototype._calculateAlignedCoords = function(x, y) {\r\n    var newX, newY;\r\n    switch (this._hAlign) {\r\n        case BboxAlignedText.ALIGN.BOX_LEFT:\r\n            newX = x;\r\n            break;\r\n        case BboxAlignedText.ALIGN.BOX_CENTER:\r\n            newX = x - this.halfWidth;\r\n            break;\r\n        case BboxAlignedText.ALIGN.BOX_RIGHT:\r\n            newX = x - this.width;\r\n            break;\r\n        default:\r\n            newX = x;\r\n            console.log(\"Unrecognized horizonal align:\", this._hAlign);\r\n            break;\r\n    }\r\n    switch (this._vAlign) {\r\n        case BboxAlignedText.BASELINE.BOX_TOP:\r\n            newY = y - this._boundsOffset.y;\r\n            break;\r\n        case BboxAlignedText.BASELINE.BOX_CENTER:\r\n            newY = y + this._distBaseToMid;\r\n            break;\r\n        case BboxAlignedText.BASELINE.BOX_BOTTOM:\r\n            newY = y - this._distBaseToBottom;\r\n            break;\r\n        case BboxAlignedText.BASELINE.FONT_CENTER:\r\n            // Height is approximated as ascent + descent\r\n            newY = y - this._descent + (this._ascent + this._descent) / 2;\r\n            break;\r\n        case BboxAlignedText.BASELINE.ALPHABETIC:\r\n            newY = y;\r\n            break;\r\n        default:\r\n            newY = y;\r\n            console.log(\"Unrecognized vertical align:\", this._vAlign);\r\n            break;\r\n    }\r\n    return {x: newX, y: newY};\r\n};\r\n\r\n\r\n/**\r\n * Calculates bounding box and various metrics for the current text and font\r\n * @private\r\n */\r\nBboxAlignedText.prototype._calculateMetrics = function(shouldUpdateHeight) {  \r\n    // p5 0.5.0 has a bug - text bounds are clipped by (0, 0)\r\n    // Calculating bounds hack\r\n    var bounds = this._font.textBounds(this._text, 1000, 1000, this._fontSize);\r\n    // Bounds is a reference - if we mess with it directly, we can mess up \r\n    // future values! (It changes the bbox cache in p5.)\r\n    bounds = { \r\n        x: bounds.x - 1000, \r\n        y: bounds.y - 1000, \r\n        w: bounds.w, \r\n        h: bounds.h \r\n    }; \r\n\r\n    if (shouldUpdateHeight) {\r\n        this._ascent = this._font._textAscent(this._fontSize);\r\n        this._descent = this._font._textDescent(this._fontSize);\r\n    }\r\n\r\n    // Use bounds to calculate font metrics\r\n    this.width = bounds.w;\r\n    this.height = bounds.h;\r\n    this.halfWidth = this.width / 2;\r\n    this.halfHeight = this.height / 2;\r\n    this._boundsOffset = { x: bounds.x, y: bounds.y };\r\n    this._distBaseToMid = Math.abs(bounds.y) - this.halfHeight;\r\n    this._distBaseToBottom = this.height - Math.abs(bounds.y);\r\n};","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = BboxAlignedText;\r\n\r\n/**\r\n * Creates a new BboxAlignedText object - a text object that can be drawn with\r\n * anchor points based on a tight bounding box around the text.\r\n * @constructor\r\n * @param {object} font               p5.Font object\r\n * @param {string} text               String to display\r\n * @param {number} [fontSize=12]      Font size to use for string\r\n * @param {object} [pInstance=window] Reference to p5 instance, leave blank if\r\n *                                    sketch is global\r\n * @example\r\n * var font, bboxText;\r\n * function preload() {\r\n *     font = loadFont(\"./assets/Regular.ttf\");\r\n * }\r\n * function setup() {\r\n *     createCanvas(400, 600);\r\n *     background(0);\r\n *     \r\n *     bboxText = new BboxAlignedText(font, \"Hey!\", 30);    \r\n *     bboxText.setRotation(PI / 4);\r\n *     bboxText.setAnchor(BboxAlignedText.ALIGN.BOX_CENTER, \r\n *                        BboxAlignedText.BASELINE.BOX_CENTER);\r\n *     \r\n *     fill(\"#00A8EA\");\r\n *     noStroke();\r\n *     bboxText.draw(width / 2, height / 2, true);\r\n * }\r\n */\r\nfunction BboxAlignedText(font, text, fontSize, pInstance) {\r\n    this._font = font;\r\n    this._text = text;\r\n    this._fontSize = (fontSize !== undefined) ? fontSize : 12;\r\n    this.p = pInstance || window; // If instance is omitted, assume global scope\r\n    this._rotation = 0;\r\n    this._hAlign = BboxAlignedText.ALIGN.BOX_CENTER;\r\n    this._vAlign = BboxAlignedText.BASELINE.BOX_CENTER;\r\n    this._calculateMetrics(true);\r\n}\r\n\r\n/**\r\n * Vertical alignment values\r\n * @public\r\n * @static\r\n * @readonly\r\n * @enum {string}\r\n */\r\nBboxAlignedText.ALIGN = {\r\n    /** Draw from the left of the bbox */\r\n    BOX_LEFT: \"box_left\",\r\n    /** Draw from the center of the bbox */\r\n    BOX_CENTER: \"box_center\",\r\n    /** Draw from the right of the bbox */\r\n    BOX_RIGHT: \"box_right\"\r\n};\r\n\r\n/**\r\n * Baseline alignment values\r\n * @public\r\n * @static\r\n * @readonly\r\n * @enum {string}\r\n */\r\nBboxAlignedText.BASELINE = {\r\n    /** Draw from the top of the bbox */\r\n    BOX_TOP: \"box_top\",\r\n    /** Draw from the center of the bbox */\r\n    BOX_CENTER: \"box_center\",\r\n    /** Draw from the bottom of the bbox */\r\n    BOX_BOTTOM: \"box_bottom\",\r\n    /** \r\n     * Draw from half the height of the font. Specifically the height is\r\n     * calculated as: ascent + descent.\r\n     */\r\n    FONT_CENTER: \"font_center\",\r\n    /** Draw from the the normal font baseline */\r\n    ALPHABETIC: \"alphabetic\"\r\n};\r\n\r\n/**\r\n * Set current text\r\n * @public\r\n * @param {string} string Text string to display\r\n */\r\nBboxAlignedText.prototype.setText = function(string) {\r\n    this._text = string;\r\n    this._calculateMetrics(false);\r\n};\r\n\r\n/**\r\n * Set current text size\r\n * @public\r\n * @param {number} fontSize Text size\r\n */\r\nBboxAlignedText.prototype.setTextSize = function(fontSize) {\r\n    this._fontSize = fontSize;\r\n    this._calculateMetrics(true);\r\n};\r\n\r\n/**\r\n * Set rotation of text\r\n * @public\r\n * @param {number} angle Rotation in radians\r\n */\r\nBboxAlignedText.prototype.setRotation = function(angle) {\r\n    this._rotation = angle;\r\n};\r\n\r\n/**\r\n * Set anchor point for text (horizonal and vertical alignment) relative to\r\n * bounding box\r\n * @public\r\n * @param {string} [hAlign=CENTER] Horizonal alignment\r\n * @param {string} [vAlign=CENTER] Vertical baseline\r\n */\r\nBboxAlignedText.prototype.setAnchor = function(hAlign, vAlign) {\r\n    this._hAlign = hAlign || BboxAlignedText.ALIGN.CENTER;\r\n    this._vAlign = vAlign || BboxAlignedText.BASELINE.CENTER;\r\n};\r\n\r\n/**\r\n * Get the bounding box when the text is placed at the specified coordinates.\r\n * Note: this is the unrotated bounding box!\r\n * @param  {number} x X coordinate\r\n * @param  {number} y Y coordinate\r\n * @return {object}   Returns an object with properties: x, y, w, h\r\n */\r\nBboxAlignedText.prototype.getBbox = function(x, y) {\r\n    var pos = this._calculateAlignedCoords(x, y);\r\n    return {\r\n        x: pos.x + this._boundsOffset.x,\r\n        y: pos.y + this._boundsOffset.y,\r\n        w: this.width,\r\n        h: this.height\r\n    };\r\n};\r\n\r\n/**\r\n * Draws the text particle with the specified style parameters. Note: this is\r\n * going to set the textFont, textSize & rotation before drawing. You should set\r\n * the color/stroke/fill that you want before drawing. This function will clean\r\n * up after itself and reset styling back to what it was before it was called.\r\n * @public\r\n * @param  {number}  [x=0]              X coordinate of text anchor\r\n * @param  {number}  [y=0]              Y coordinate of text anchor\r\n * @param  {boolean} [drawBounds=false] Flag for drawing bounding box\r\n */\r\nBboxAlignedText.prototype.draw = function(x, y, drawBounds) {\r\n    drawBounds = drawBounds || false;\r\n    var pos = {\r\n        x: (x !== undefined) ? x : 0, \r\n        y: (y !== undefined) ? y : 0\r\n    };\r\n\r\n    this.p.push();\r\n\r\n        if (this._rotation) {\r\n            pos = this._calculateRotatedCoords(pos.x, pos.y, this._rotation);\r\n            this.p.rotate(this._rotation);\r\n        }\r\n\r\n        pos = this._calculateAlignedCoords(pos.x, pos.y);\r\n\r\n        this.p.textAlign(this.p.LEFT, this.p.BASELINE);\r\n        this.p.textFont(this._font);\r\n        this.p.textSize(this._fontSize);\r\n        this.p.text(this._text, pos.x, pos.y);\r\n\r\n        if (drawBounds) {\r\n            this.p.stroke(200);\r\n            var boundsX = pos.x + this._boundsOffset.x;\r\n            var boundsY = pos.y + this._boundsOffset.y;\r\n            this.p.noFill();\r\n            this.p.rect(boundsX, boundsY, this.width, this.height);            \r\n        }\r\n\r\n    this.p.pop();\r\n};\r\n\r\n/**\r\n * Project the coordinates (x, y) into a rotated coordinate system\r\n * @private\r\n * @param  {number} x     X coordinate (in unrotated space)\r\n * @param  {number} y     Y coordinate (in unrotated space)\r\n * @param  {number} angle Radians of rotation to apply\r\n * @return {object}       Object with x & y properties\r\n */\r\nBboxAlignedText.prototype._calculateRotatedCoords = function (x, y, angle) {  \r\n    var rx = Math.cos(angle) * x + Math.cos(Math.PI / 2 - angle) * y;\r\n    var ry = -Math.sin(angle) * x + Math.sin(Math.PI / 2 - angle) * y;\r\n    return {x: rx, y: ry};\r\n};\r\n\r\n/**\r\n * Calculates draw coordinates for the text, aligning based on the bounding box.\r\n * The text is eventually drawn with canvas alignment set to left & baseline, so\r\n * this function takes a desired pos & alignment and returns the appropriate\r\n * coordinates for the left & baseline.\r\n * @private\r\n * @param  {number} x      X coordinate\r\n * @param  {number} y      Y coordinate\r\n * @return {object}        Object with x & y properties\r\n */\r\nBboxAlignedText.prototype._calculateAlignedCoords = function(x, y) {\r\n    var newX, newY;\r\n    switch (this._hAlign) {\r\n        case BboxAlignedText.ALIGN.BOX_LEFT:\r\n            newX = x;\r\n            break;\r\n        case BboxAlignedText.ALIGN.BOX_CENTER:\r\n            newX = x - this.halfWidth;\r\n            break;\r\n        case BboxAlignedText.ALIGN.BOX_RIGHT:\r\n            newX = x - this.width;\r\n            break;\r\n        default:\r\n            newX = x;\r\n            console.log(\"Unrecognized horizonal align:\", this._hAlign);\r\n            break;\r\n    }\r\n    switch (this._vAlign) {\r\n        case BboxAlignedText.BASELINE.BOX_TOP:\r\n            newY = y - this._boundsOffset.y;\r\n            break;\r\n        case BboxAlignedText.BASELINE.BOX_CENTER:\r\n            newY = y + this._distBaseToMid;\r\n            break;\r\n        case BboxAlignedText.BASELINE.BOX_BOTTOM:\r\n            newY = y - this._distBaseToBottom;\r\n            break;\r\n        case BboxAlignedText.BASELINE.FONT_CENTER:\r\n            // Height is approximated as ascent + descent\r\n            newY = y - this._descent + (this._ascent + this._descent) / 2;\r\n            break;\r\n        case BboxAlignedText.BASELINE.ALPHABETIC:\r\n            newY = y;\r\n            break;\r\n        default:\r\n            newY = y;\r\n            console.log(\"Unrecognized vertical align:\", this._vAlign);\r\n            break;\r\n    }\r\n    return {x: newX, y: newY};\r\n};\r\n\r\n\r\n/**\r\n * Calculates bounding box and various metrics for the current text and font\r\n * @private\r\n */\r\nBboxAlignedText.prototype._calculateMetrics = function(shouldUpdateHeight) {  \r\n    // p5 0.5.0 has a bug - text bounds are clipped by (0, 0)\r\n    // Calculating bounds hack\r\n    var bounds = this._font.textBounds(this._text, 1000, 1000, this._fontSize);\r\n    // Bounds is a reference - if we mess with it directly, we can mess up \r\n    // future values! (It changes the bbox cache in p5.)\r\n    bounds = { \r\n        x: bounds.x - 1000, \r\n        y: bounds.y - 1000, \r\n        w: bounds.w, \r\n        h: bounds.h \r\n    }; \r\n\r\n    if (shouldUpdateHeight) {\r\n        this._ascent = this._font._textAscent(this._fontSize);\r\n        this._descent = this._font._textDescent(this._fontSize);\r\n    }\r\n\r\n    // Use bounds to calculate font metrics\r\n    this.width = bounds.w;\r\n    this.height = bounds.h;\r\n    this.halfWidth = this.width / 2;\r\n    this.halfHeight = this.height / 2;\r\n    this._boundsOffset = { x: bounds.x, y: bounds.y };\r\n    this._distBaseToMid = Math.abs(bounds.y) - this.halfHeight;\r\n    this._distBaseToBottom = this.height - Math.abs(bounds.y);\r\n};\n},{}],2:[function(require,module,exports){\nmodule.exports = {\r\n    NoiseGenerator1D: NoiseGenerator1D,\r\n    NoiseGenerator2D: NoiseGenerator2D\r\n};\r\n\r\n// -- 1D Noise Generator -------------------------------------------------------\r\n\r\n/**\r\n * A utility class for generating noise values\r\n * @constructor\r\n * @param {object} p               Reference to a p5 sketch\r\n * @param {number} [min=0]         Minimum value for the noise\r\n * @param {number} [max=1]         Maximum value for the noise\r\n * @param {number} [increment=0.1] Scale of the noise, used when updating\r\n * @param {number} [offset=random] A value used to ensure multiple noise\r\n *                                 generators are returning \"independent\" values\r\n */\r\nfunction NoiseGenerator1D(p, min, max, increment, offset) {\r\n    this.p = p;\r\n    this.min = (min !== undefined) ? min : 0;\r\n    this.max = (max !== undefined) ? max : 1;\r\n    this.increment = (increment !== undefined) ? increment : 0.1;\r\n    this.position = (offset !== undefined) ? offset : \r\n                                            p.random(-1000000, 1000000);\r\n}\r\n\r\n/**\r\n * Update the min and max noise values\r\n * @param  {number} min Minimum noise value\r\n * @param  {number} max Maximum noise value\r\n */\r\nNoiseGenerator1D.prototype.setBounds = function (min, max) {\r\n    if (min !== undefined) this.min = min;\r\n    if (max !== undefined) this.max = max;\r\n};\r\n\r\n/**\r\n * Update the noise increment (e.g. scale)\r\n * @param  {number} increment New increment (scale) value\r\n */\r\nNoiseGenerator1D.prototype.setIncrement = function (increment) {\r\n    if (increment !== undefined) this.increment = increment;\r\n};\r\n\r\n/** \r\n * Generate the next noise value\r\n * @return {number} A noisy value between object's min and max\r\n */\r\nNoiseGenerator1D.prototype.generate = function () {\r\n    this._update();\r\n    var n = this.p.noise(this.position);\r\n    n = this.p.map(n, 0, 1, this.min, this.max);\r\n    return n;\r\n};\r\n\r\n/**\r\n * Internal update method for generating next noise value\r\n * @private\r\n */\r\nNoiseGenerator1D.prototype._update = function () {\r\n    this.position += this.increment;\r\n};\r\n\r\n\r\n// -- 2D Noise Generator -------------------------------------------------------\r\n\r\nfunction NoiseGenerator2D(p, xMin, xMax, yMin, yMax, xIncrement, yIncrement, \r\n                          xOffset, yOffset) {\r\n    this.xNoise = new NoiseGenerator1D(p, xMin, xMax, xIncrement, xOffset);\r\n    this.yNoise = new NoiseGenerator1D(p, yMin, yMax, yIncrement, yOffset);\r\n    this.p = p;\r\n}\r\n\r\n/**\r\n * Update the min and max noise values\r\n * @param  {object} options Object with bounds to be updated e.g. \r\n *                          { xMin: 0, xMax: 1, yMin: -1, yMax: 1 }\r\n */\r\nNoiseGenerator2D.prototype.setBounds = function (options) {\r\n    if (!options) return;\r\n    if (options.xMin !== undefined) this.xMin = options.xMin;\r\n    if (options.xMax !== undefined) this.xMax = options.xMax;\r\n    if (options.yMin !== undefined) this.yMin = options.yMin;\r\n    if (options.yMax !== undefined) this.yMax = options.yMax;\r\n};\r\n\r\n/**\r\n * Update the increment (e.g. scale) for the noise generator\r\n * @param  {object} options Object with bounds to be updated e.g. \r\n *                          { xIncrement: 0.05, yIncrement: 0.1 }\r\n */\r\nNoiseGenerator2D.prototype.setBounds = function (options) {\r\n    if (!options) return;\r\n    if (options.xIncrement !== undefined) this.xNoise.setIncrement(\r\n                                                            options.xIncrement);\r\n    if (options.yIncrement !== undefined) this.yNoise.setIncrement(\r\n                                                            options.yIncrement);\r\n};\r\n\r\n/**\r\n * Generate the next pair of noise values\r\n * @return {object} Object with x and y properties that contain the next noise\r\n *                  values along each dimension\r\n */\r\nNoiseGenerator2D.prototype.generate = function () {\r\n    return {\r\n        x: this.xNoise.generate(),\r\n        y: this.yNoise.generate()\r\n    };\r\n};\n},{}],3:[function(require,module,exports){\nmodule.exports = SinGenerator;\r\n\r\n/**\r\n * A utility class for generating values along a sinwave\r\n * @constructor\r\n * @param {object} p               Reference to a p5 sketch\r\n * @param {number} [min=0]         Minimum value for the noise\r\n * @param {number} [max=1]         Maximum value for the noise\r\n * @param {number} [increment=0.1] Increment used when updating\r\n * @param {number} [offset=random] Where to start along the sinewave\r\n */\r\nfunction SinGenerator(p, min, max, angleIncrement, startingAngle) {\r\n    this.p = p;\r\n    this.min = (min !== undefined) ? min : 0;\r\n    this.max = (max !== undefined) ? max : 1;\r\n    this.increment = (angleIncrement !== undefined) ? angleIncrement : 0.1;\r\n    this.angle = (startingAngle !== undefined) ? startingAngle :\r\n                                                 p.random(-1000000, 1000000);\r\n}\r\n\r\n/**\r\n * Update the min and max values\r\n * @param  {number} min Minimum value\r\n * @param  {number} max Maximum value\r\n */\r\nSinGenerator.prototype.setBounds = function (min, max) {\r\n    if (min !== undefined) this.min = min;\r\n    if (max !== undefined) this.max = max;\r\n};\r\n\r\n/**\r\n * Update the angle increment (e.g. how fast we move through the sinwave)\r\n * @param  {number} increment New increment value\r\n */\r\nSinGenerator.prototype.setIncrement = function (increment) {\r\n    if (increment !== undefined) this.increment = increment;\r\n};\r\n\r\n/** \r\n * Generate the next value\r\n * @return {number} A value between generators's min and max\r\n */\r\nSinGenerator.prototype.generate = function () {\r\n    this._update();\r\n    var n = this.p.sin(this.angle);\r\n    n = this.p.map(n, -1, 1, this.min, this.max);\r\n    return n;\r\n};\r\n\r\n/**\r\n * Internal update method for generating next value\r\n * @private\r\n */\r\nSinGenerator.prototype._update = function () {\r\n    this.angle += this.increment;\r\n};\n},{}],4:[function(require,module,exports){\nrequire(\"./sketches/noisy-word.js\")();\r\nrequire(\"./sketches/halftone-flashlight-word.js\")();\r\nrequire(\"./sketches/word-particle-wrapping.js\")();\r\nrequire(\"./sketches/fleeing-halftones.js\")();\n},{\"./sketches/fleeing-halftones.js\":7,\"./sketches/halftone-flashlight-word.js\":8,\"./sketches/noisy-word.js\":9,\"./sketches/word-particle-wrapping.js\":10}],5:[function(require,module,exports){\nmodule.exports = FleeingParticle;\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\n\r\nfunction FleeingParticle(p, color, radius, position, velocity) {\r\n    this.p = p;\r\n    this._pos = position.copy();\r\n    this._initPos = position.copy();\r\n    this._vel = velocity;\r\n    this._color = color;\r\n    this._radius = radius;\r\n    this._noiseGenerator = new Noise.NoiseGenerator1D(p, 0, 1, 0.1);\r\n    this._maxVelocity = 5;\r\n\r\n    this._xMax = this.p.width + this._radius;\r\n    this._xMin = -this._radius;\r\n    this._yMax = this.p.height + this._radius;\r\n    this._yMin = -this._radius;\r\n}\r\n\r\nFleeingParticle.prototype.headTowardsInitial = function () {\r\n    var dx = this._initPos.x - this._pos.x;\r\n    var dy = this._initPos.y - this._pos.y;\r\n    var dist = Math.sqrt(dx * dx + dy * dy);\r\n    var angle = this.p.atan2(dy, dx);\r\n\r\n    var noiseMax = this.p.map(dist, 50, 0, this.p.TWO_PI/2, 0);\r\n    noiseMax = Math.min(noiseMax, this.p.TWO_PI/2);\r\n    var noise = this._noiseGenerator.generate();\r\n    noise = this.p.map(noise, 0, 1, -noiseMax, noiseMax);\r\n    angle += noise;\r\n\r\n    this._vel.x = Math.cos(angle) * Math.min(this._maxVelocity, dist);\r\n    this._vel.y = Math.sin(angle) * Math.min(this._maxVelocity, dist);\r\n};\r\n\r\nFleeingParticle.prototype.avoid = function (x, y) {\r\n    var dx = this._pos.x - x;\r\n    var dy = this._pos.y - y;\r\n    var angle = this.p.atan2(dy, dx);\r\n    var dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    var noiseMax = this.p.map(dist, 0, 50, 0, this.p.TWO_PI/2);\r\n    noiseMax = Math.min(noiseMax, this.p.TWO_PI/2);\r\n    var noise = this._noiseGenerator.generate();\r\n    noise = this.p.map(noise, 0, 1, -noiseMax, noiseMax);\r\n    angle += noise;\r\n\r\n    this._vel.x = Math.cos(angle) * this._maxVelocity;\r\n    this._vel.y = Math.sin(angle) * this._maxVelocity;\r\n};\r\n\r\nFleeingParticle.prototype.update = function () {\r\n    this._pos.add(this._vel);\r\n};\r\n\r\nFleeingParticle.prototype.draw = function () {\r\n    if (this._isOffscreen()) return;\r\n    this.p.push();\r\n        this.p.fill(this._color);\r\n        this.p.noStroke();\r\n        this.p.ellipse(this._pos.x, this._pos.y, this._radius, this._radius);\r\n    this.p.pop();\r\n};\r\n\r\nFleeingParticle.prototype._isOffscreen = function () {\r\n    if (this._pos.x > this._xMax) return true;\r\n    if (this._pos.x < this._xMin) return true;    \r\n    if (this._pos.y > this._yMax) return true;    \r\n    if (this._pos.y < this._yMin) return true;\r\n    return false;\r\n};\n},{\"../generators/noise-generators.js\":2}],6:[function(require,module,exports){\nmodule.exports = TextParticle;\r\n\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\n\r\nfunction TextParticle(p, font, fontSize, text, position, velocity) {\r\n    this.p = p;\r\n    this._pos = position;\r\n    this._vel = velocity;\r\n    this._rotation = 0;\r\n    this._bboxText = new BboxText(font, text, fontSize, p);\r\n    this._bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                             BboxText.BASELINE.BOX_CENTER);\r\n\r\n    // Calculate particle bounds\r\n    var bounds = this._bboxText.getBbox(this._pos.x, this._pos.y);\r\n    this.width = bounds.w;\r\n    this.halfWidth = bounds.w / 2;\r\n    this.height = bounds.h;\r\n    this.halfHeight = bounds.h / 2;\r\n\r\n    // Holding on to the offscreen position for when the word is partially \r\n    // offscreen, but not completely offscreen.\r\n    this._wrappedPos = null;\r\n    this._xReflectPos = null;\r\n    this._yReflectPos = null;\r\n}\r\n\r\nTextParticle.prototype.setVelocity = function (velocity) {\r\n    this._vel.x = velocity.x;\r\n    this._vel.y = velocity.y;\r\n};\r\n\r\nTextParticle.prototype.setRotation = function (radians) {\r\n    this._bboxText.setRotation(radians);\r\n};\r\n\r\nTextParticle.prototype.update = function () {\r\n    // Update position\r\n    this._pos.add(this._vel);\r\n\r\n    // If the particle is partially offscreen (but not fully), draw two \r\n    // particles - one that is wrapped around the screen and one that is not.\r\n    this._wrappedPos = this._pos.copy();\r\n    this._xReflectPos = this._pos.copy();\r\n    this._yReflectPos = this._pos.copy();\r\n\r\n    // Calculate the positions of the sides of the particle\r\n    var left = this._pos.x - this.halfWidth;\r\n    var right = this._pos.x + this.halfWidth;\r\n    var top = this._pos.y - this.halfHeight;\r\n    var bottom = this._pos.y + this.halfHeight;\r\n\r\n    var amountOffscreen, distBeyondWrap;\r\n\r\n    // Check if word is offscreen along x-axis\r\n    if (right > this.p.width) {\r\n        amountOffscreen = right - this.p.width;\r\n        if (amountOffscreen > this.width) {\r\n            // Word is completely off the right edge of the screen, so it\r\n            // needs to be wrapped around to the left side of the screen. It is\r\n            // important to account for the \"remainder\" to get smooth motion:\r\n            // (amountOffscreen - this.width) = distance from left edge of word\r\n            //                                  to the right edge of the screen\r\n            distBeyondWrap = (amountOffscreen - this.width);\r\n            this._pos.x = this.halfWidth + distBeyondWrap;\r\n            // If the particle wraps around the y-axis, we want to keep the x\r\n            // position up to date\r\n            this._wrappedPos.x = this._pos.x;\r\n        }\r\n        else {\r\n            // Word is only partially off the right edge of the screen, so the\r\n            // wrappedPos is going to be used. Project what the position of the\r\n            // particle would be if it were wrapped around the left edge of the\r\n            // screen\r\n            this._wrappedPos.x = -this.halfWidth + amountOffscreen;\r\n            this._xReflectPos.x = -this.halfWidth + amountOffscreen;\r\n        }\r\n    }\r\n    else if (left < 0) {\r\n        amountOffscreen = -left;\r\n        if (amountOffscreen > this.width) {\r\n            // Word is completely off the left edge of the screen, so it needs\r\n            // to be wrapped around to the right side of the screen\r\n            distBeyondWrap = (amountOffscreen - this.width);\r\n            this._pos.x = (this.p.width - this.halfWidth) - distBeyondWrap;\r\n            this._wrappedPos.x = this._pos.x;\r\n        }\r\n        else {\r\n            // Word is only partially off the left edge of the screen\r\n            this._wrappedPos.x = (this.p.width + this.halfWidth) - amountOffscreen;\r\n            this._xReflectPos.x = (this.p.width + this.halfWidth) - amountOffscreen;\r\n        }\r\n    }\r\n\r\n    // Check if word is offscreen along y-axis\r\n    if (bottom > this.p.height) {\r\n        amountOffscreen = bottom - this.p.height;\r\n        if (amountOffscreen > this.height) {\r\n            // Word is completely off the bottom edge of the screen, so it\r\n            // needs to be wrapped around to the top side of the screen \r\n            distBeyondWrap = (amountOffscreen - this.height);\r\n            this._pos.y = this.halfHeight + distBeyondWrap;\r\n            // If the particle wraps around the x-axis, we want to keep the y\r\n            // position up to date\r\n            this._wrappedPos.y = this._pos.y;\r\n        }\r\n        else {\r\n            // Word is only partially off the bottom edge of the screen\r\n            this._wrappedPos.y = -this.halfHeight + amountOffscreen;\r\n            this._yReflectPos.y = -this.halfHeight + amountOffscreen;\r\n        }\r\n    }\r\n    else if (top < 0) {\r\n        amountOffscreen = -top;\r\n        if (amountOffscreen > this.height) {\r\n            // Word is completely off the top edge of the screen, so it needs\r\n            // to be wrapped around to the bottom side of the screen\r\n            distBeyondWrap = (amountOffscreen - this.height);\r\n            this._pos.y = (this.p.height - this.halfHeight) - distBeyondWrap;\r\n            this._wrappedPos.y = this._pos.y;\r\n        }\r\n        else {\r\n            // Word is only partially off the top edge of the screen\r\n            this._wrappedPos.y = (this.p.height + this.halfHeight) - amountOffscreen;\r\n            this._yReflectPos.y = (this.p.height + this.halfHeight) - amountOffscreen;\r\n        }\r\n    }\r\n\r\n};\r\n\r\nTextParticle.prototype.draw = function () {\r\n    this._bboxText.draw(this._pos.x, this._pos.y, this._rotation);\r\n\r\n    if (!this._wrappedPos.equals(this._pos)) {\r\n        // wrappedPos has a different value, so the particle is offscreen       \r\n        this._bboxText.draw(this._wrappedPos.x, this._wrappedPos.y, \r\n                            this._rotation);\r\n    }\r\n    \r\n    if (this._xReflectPos.x !== this._pos.x) {        \r\n        this._xReflectPos.y = this._pos.y;\r\n        this._bboxText.draw(this._xReflectPos.x, this._xReflectPos.y,\r\n                            this._rotation);\r\n    }\r\n\r\n    if (this._yReflectPos.y !== this._pos.y) {        \r\n        this._yReflectPos.x = this._pos.x;\r\n        this._bboxText.draw(this._yReflectPos.x, this._yReflectPos.y, \r\n                            this._rotation);\r\n    }\r\n};\n},{\"p5-bbox-aligned-text\":1}],7:[function(require,module,exports){\nmodule.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\nvar FleeingParticle = require(\"../particles/fleeing-particle.js\");\r\n\r\n// Globals\r\nvar p, font;\r\nvar particles = [];\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"scatter\";\r\nvar fontSize = 140;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \"josefin-slab/JosefinSlab-Bold.ttf\";\r\n\r\nfunction startSketch() { \r\n    // Create div on page for the sketch\r\n    var id = \"fleeing-halftones\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textSize(fontSize);\r\n    bboxText = new BboxText(font, text, fontSize, p);\r\n    bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                       BboxText.BASELINE.FONT_CENTER);\r\n    p.noStroke();\r\n    p.fill(\"#0A000A\");    \r\n    bboxText.draw(p.width / 2, p.height / 2);\r\n\r\n    // Loop over the pixels in the text's bounding box to sample the word\r\n    var bbox = bboxText.getBbox(p.width / 2, p.height / 2);\r\n    var startX = Math.floor(Math.max(bbox.x - 5, 0));\r\n    var endX = Math.ceil(Math.min(bbox.x + bbox.w + 5, p.width));\r\n    var startY = Math.floor(Math.max(bbox.y - 5, 0));\r\n    var endY = Math.ceil(Math.min(bbox.y + bbox.h + 5, p.height));\r\n    var spacing = 5;\r\n    p.loadPixels();\r\n    p.pixelDensity(1);\r\n    circles = [];\r\n    var jitter = p.random.bind(p, -2/3 * spacing, 2/3 * spacing);\r\n    var particleRadius = 8;\r\n    for (var y = startY; y < endY; y += spacing) {\r\n        for (var x = startX; x < endX; x += spacing) {  \r\n            var i = 4 * ((y * p.width) + x);\r\n            var r = p.pixels[i];\r\n            var g = p.pixels[i + 1];\r\n            var b = p.pixels[i + 2];\r\n            var a = p.pixels[i + 3];\r\n            var c = p.color(r, g, b, a);\r\n            if (p.saturation(c) > 0) {\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity(); \r\n                var col = p.color(\"#06FFFF\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity();\r\n                var col = p.color(\"#FE00FE\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity();\r\n                var col = p.color(\"#FFFF04\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n            }\r\n        }\r\n    }\r\n    p.updatePixels();\r\n}\r\n\r\nfunction randomVelocity() {\r\n    var angle = p.random(0, p.TWO_PI);\r\n    var magnitude = p.random(2, 10);\r\n    var velocity = p.createVector(magnitude * Math.cos(angle),\r\n                                  magnitude * Math.sin(angle));\r\n    return velocity;\r\n}\r\n\r\nfunction draw() {\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Clear\r\n    p.blendMode(p.BLEND);\r\n    p.background(255);\r\n\r\n    // Draw \"halftone\" logo\r\n    p.noStroke();   \r\n    p.blendMode(p.MULTIPLY);\r\n    for (var i = 0; i < particles.length; i += 1) {\r\n        var particle = particles[i];\r\n\r\n        if (isMouseOver) particle.avoid(p.mouseX, p.mouseY);\r\n        else particle.headTowardsInitial();\r\n\r\n        particle.update();\r\n        particle.draw();\r\n    }\r\n}\n},{\"../generators/noise-generators.js\":2,\"../particles/fleeing-particle.js\":5,\"../utilities/dom-utilities.js\":11,\"p5-bbox-aligned-text\":1}],8:[function(require,module,exports){\nmodule.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\n\r\n// Globals\r\nvar p, font, circles, bboxText;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"halftone\";\r\nvar fontSize = 150;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"theleagueof-league-gothic/leaguegothic-regular-webfont.ttf\";\r\n\r\nfunction startSketch() { \r\n    // Create div on page for the sketch\r\n    var id = \"halftone-flashlight-word\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textSize(fontSize);\r\n    bboxText = new BboxText(font, text, fontSize, p);\r\n    bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                       BboxText.BASELINE.FONT_CENTER);\r\n    p.noStroke();\r\n    p.fill(\"#0A000A\");    \r\n    bboxText.draw(p.width / 2, p.height / 2);\r\n\r\n\r\n    // Loop over the pixels in the text's bounding box to sample the word\r\n    var bbox = bboxText.getBbox(p.width / 2, p.height / 2);\r\n    var startX = Math.floor(Math.max(bbox.x - 5, 0));\r\n    var endX = Math.ceil(Math.min(bbox.x + bbox.w + 5, p.width));\r\n    var startY = Math.floor(Math.max(bbox.y - 5, 0));\r\n    var endY = Math.ceil(Math.min(bbox.y + bbox.h + 5, p.height));\r\n    var spacing = 5;\r\n    p.loadPixels();\r\n    p.pixelDensity(1);\r\n    circles = [];\r\n    for (var y = startY; y < endY; y += spacing) {\r\n        for (var x = startX; x < endX; x += spacing) {  \r\n            var i = 4 * ((y * p.width) + x);\r\n            var r = p.pixels[i];\r\n            var g = p.pixels[i + 1];\r\n            var b = p.pixels[i + 2];\r\n            var a = p.pixels[i + 3];\r\n            var c = p.color(r, g, b, a);\r\n            if (p.saturation(c) > 0) {\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#06FFFF\")\r\n                });\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#FE00FE\")\r\n                });\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#FFFF04\")\r\n                });\r\n            }\r\n        }\r\n    }\r\n    p.updatePixels();\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Clear\r\n    p.blendMode(p.BLEND);\r\n    p.background(255);\r\n\r\n    // Draw \"halftone\" logo\r\n    p.noStroke();   \r\n    p.blendMode(p.MULTIPLY);\r\n    for (var i = 0; i < circles.length; i += 1) {\r\n        var circle = circles[i];\r\n        var c = circle.color;\r\n        var dist = p.dist(circle.x, circle.y, p.mouseX, p.mouseY);\r\n        var radius = p.map(dist, 0, 150, 1, 10);\r\n        p.fill(c);\r\n        p.ellipse(circle.x, circle.y, radius, radius);\r\n    }\r\n}\n},{\"../generators/noise-generators.js\":2,\"../utilities/dom-utilities.js\":11,\"p5-bbox-aligned-text\":1}],9:[function(require,module,exports){\nmodule.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\n\r\n// Globals\r\nvar p, font, rotationNoise, xyNoise;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"Squiggle\";\r\nvar fontSize = 100;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"theleagueof-league-gothic/leaguegothic-regular-webfont.ttf\";\r\n\r\nfunction startSketch() {    \r\n    // Create div on page for the sketch\r\n    var id = \"noisy-word\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textFont(font);\r\n    p.textSize(fontSize);\r\n    p.textAlign(p.CENTER, p.CENTER);\r\n    p.stroke(255);\r\n    p.fill(\"#0A000A\");\r\n    p.strokeWeight(2);      \r\n    p.text(text, p.width / 2, p.height / 2);\r\n\r\n    // Set up noise generators\r\n    rotationNoise = new Noise.NoiseGenerator1D(p, -p.PI/4, p.PI/4, 0.02); \r\n    xyNoise = new Noise.NoiseGenerator2D(p, -100, 100, -50, 50, 0.01, 0.01);\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Calculate position and rotation to create a jittery logo\r\n    var rotation = rotationNoise.generate();\r\n    var xyOffset = xyNoise.generate();\r\n\r\n    // Draw the logo\r\n    p.push();\r\n        p.translate(p.width / 2 + xyOffset.x, p.height / 2 + xyOffset.y);\r\n        p.rotate(rotation);\r\n        p.text(text, 0, 0);\r\n    p.pop();\r\n}\n},{\"../generators/noise-generators.js\":2,\"../utilities/dom-utilities.js\":11}],10:[function(require,module,exports){\nmodule.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar SinGenerator = require(\"../generators/sin-generator.js\");\r\nvar TextParticle = require(\"../particles/text-particle.js\");\r\n\r\n// Globals\r\nvar p, font, textParticle, rotationGenerator, sinGenerator;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"Ripple\";\r\nvar fontSize = 50;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"league-spartan/leaguespartan-bold.ttf\";\r\n\r\nfunction startSketch() {    \r\n    // Create div on page for the sketch\r\n    var id = \"word-particle-wrapping\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textFont(font);\r\n    p.textSize(fontSize);\r\n    p.textAlign(p.CENTER, p.CENTER);\r\n    p.stroke(255);\r\n    p.fill(\"#00ACE0\");\r\n    p.strokeWeight(2);      \r\n    p.text(text, p.width / 2, p.height / 2);\r\n\r\n    // Create the word particle\r\n    var pos = p.createVector(p.width / 2, p.height / 2);\r\n    var vel = p.createVector(3, -1); \r\n    textParticle = new TextParticle(p, font, fontSize, text, pos, vel);\r\n\r\n    rotationGenerator = new SinGenerator(p, -Math.PI/5, Math.PI/5, 0.06);\r\n    directionGenerator = new Noise.NoiseGenerator1D(p, 0, p.TWO_PI, 0.005);\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Update the particles velocity and rotation\r\n    var angle = directionGenerator.generate();\r\n    textParticle.setVelocity({x: p.cos(angle) * 1.25, y: p.sin(angle) * 1.25});\r\n    var rotation = rotationGenerator.generate();\r\n    textParticle.setRotation(rotation);\r\n    textParticle.update();\r\n\r\n    // Draw the particle\r\n    p.fill(\"#00ACE0\");\r\n    p.stroke(255);\r\n    p.strokeWeight(1);\r\n    textParticle.draw();\r\n}\n},{\"../generators/noise-generators.js\":2,\"../generators/sin-generator.js\":3,\"../particles/text-particle.js\":6,\"../utilities/dom-utilities.js\":11}],11:[function(require,module,exports){\nmodule.exports.forEachInObject = function (object, iterationFunction) {\r\n\tif (!object) return;\r\n\tfor (var key in object) {\r\n\t\tif (!object.hasOwnProperty(key)) continue;\r\n\t\titerationFunction(key, object[key], object);\r\n\t}\r\n};\r\n\r\nmodule.exports.createElement = function (tagName, parameters, parent) {\r\n\tvar el = document.createElement(tagName);\r\n\tif (parameters) {\r\n\t\tif (parameters.textContent) el.textContent = parameters.textContent;\r\n\t\tif (parameters.id) el.id = parameters.id;\r\n\t\tif (parameters.className) el.className = parameters.className;\r\n\t\tif (parameters.style) addStyle(el, parameters.style);\r\n\t\tif (parameters.attributes) addAttributes(el, parameters.attributes);\r\n\t}\t\r\n\tif (parent) parent.appendChild(el);\r\n\treturn el;\r\n};\r\n\r\nmodule.exports.addStyle = function (element, style) {\r\n\tif (!style) return;\r\n\tforEachInObject(style, function (key, val) {\r\n\t\telement.style[key] = val;\r\n\t});\t\r\n};\r\n\r\nmodule.exports.addAttributes = function (element, attributes) {\r\n\tif (!attributes) return;\r\n\tforEachInObject(attributes, function (key, val) {\r\n\t\telement[key] = val;\r\n\t});\t\r\n};\r\n\r\nmodule.exports.removeElement = function (element) {\r\n\telement.parentElement.removeChild(element);\r\n};\n},{}]},{},[4])\n\n","module.exports = {\r\n    NoiseGenerator1D: NoiseGenerator1D,\r\n    NoiseGenerator2D: NoiseGenerator2D\r\n};\r\n\r\n// -- 1D Noise Generator -------------------------------------------------------\r\n\r\n/**\r\n * A utility class for generating noise values\r\n * @constructor\r\n * @param {object} p               Reference to a p5 sketch\r\n * @param {number} [min=0]         Minimum value for the noise\r\n * @param {number} [max=1]         Maximum value for the noise\r\n * @param {number} [increment=0.1] Scale of the noise, used when updating\r\n * @param {number} [offset=random] A value used to ensure multiple noise\r\n *                                 generators are returning \"independent\" values\r\n */\r\nfunction NoiseGenerator1D(p, min, max, increment, offset) {\r\n    this.p = p;\r\n    this.min = (min !== undefined) ? min : 0;\r\n    this.max = (max !== undefined) ? max : 1;\r\n    this.increment = (increment !== undefined) ? increment : 0.1;\r\n    this.position = (offset !== undefined) ? offset : \r\n                                            p.random(-1000000, 1000000);\r\n}\r\n\r\n/**\r\n * Update the min and max noise values\r\n * @param  {number} min Minimum noise value\r\n * @param  {number} max Maximum noise value\r\n */\r\nNoiseGenerator1D.prototype.setBounds = function (min, max) {\r\n    if (min !== undefined) this.min = min;\r\n    if (max !== undefined) this.max = max;\r\n};\r\n\r\n/**\r\n * Update the noise increment (e.g. scale)\r\n * @param  {number} increment New increment (scale) value\r\n */\r\nNoiseGenerator1D.prototype.setIncrement = function (increment) {\r\n    if (increment !== undefined) this.increment = increment;\r\n};\r\n\r\n/** \r\n * Generate the next noise value\r\n * @return {number} A noisy value between object's min and max\r\n */\r\nNoiseGenerator1D.prototype.generate = function () {\r\n    this._update();\r\n    var n = this.p.noise(this.position);\r\n    n = this.p.map(n, 0, 1, this.min, this.max);\r\n    return n;\r\n};\r\n\r\n/**\r\n * Internal update method for generating next noise value\r\n * @private\r\n */\r\nNoiseGenerator1D.prototype._update = function () {\r\n    this.position += this.increment;\r\n};\r\n\r\n\r\n// -- 2D Noise Generator -------------------------------------------------------\r\n\r\nfunction NoiseGenerator2D(p, xMin, xMax, yMin, yMax, xIncrement, yIncrement, \r\n                          xOffset, yOffset) {\r\n    this.xNoise = new NoiseGenerator1D(p, xMin, xMax, xIncrement, xOffset);\r\n    this.yNoise = new NoiseGenerator1D(p, yMin, yMax, yIncrement, yOffset);\r\n    this.p = p;\r\n}\r\n\r\n/**\r\n * Update the min and max noise values\r\n * @param  {object} options Object with bounds to be updated e.g. \r\n *                          { xMin: 0, xMax: 1, yMin: -1, yMax: 1 }\r\n */\r\nNoiseGenerator2D.prototype.setBounds = function (options) {\r\n    if (!options) return;\r\n    if (options.xMin !== undefined) this.xMin = options.xMin;\r\n    if (options.xMax !== undefined) this.xMax = options.xMax;\r\n    if (options.yMin !== undefined) this.yMin = options.yMin;\r\n    if (options.yMax !== undefined) this.yMax = options.yMax;\r\n};\r\n\r\n/**\r\n * Update the increment (e.g. scale) for the noise generator\r\n * @param  {object} options Object with bounds to be updated e.g. \r\n *                          { xIncrement: 0.05, yIncrement: 0.1 }\r\n */\r\nNoiseGenerator2D.prototype.setBounds = function (options) {\r\n    if (!options) return;\r\n    if (options.xIncrement !== undefined) this.xNoise.setIncrement(\r\n                                                            options.xIncrement);\r\n    if (options.yIncrement !== undefined) this.yNoise.setIncrement(\r\n                                                            options.yIncrement);\r\n};\r\n\r\n/**\r\n * Generate the next pair of noise values\r\n * @return {object} Object with x and y properties that contain the next noise\r\n *                  values along each dimension\r\n */\r\nNoiseGenerator2D.prototype.generate = function () {\r\n    return {\r\n        x: this.xNoise.generate(),\r\n        y: this.yNoise.generate()\r\n    };\r\n};","module.exports = SinGenerator;\r\n\r\n/**\r\n * A utility class for generating values along a sinwave\r\n * @constructor\r\n * @param {object} p               Reference to a p5 sketch\r\n * @param {number} [min=0]         Minimum value for the noise\r\n * @param {number} [max=1]         Maximum value for the noise\r\n * @param {number} [increment=0.1] Increment used when updating\r\n * @param {number} [offset=random] Where to start along the sinewave\r\n */\r\nfunction SinGenerator(p, min, max, angleIncrement, startingAngle) {\r\n    this.p = p;\r\n    this.min = (min !== undefined) ? min : 0;\r\n    this.max = (max !== undefined) ? max : 1;\r\n    this.increment = (angleIncrement !== undefined) ? angleIncrement : 0.1;\r\n    this.angle = (startingAngle !== undefined) ? startingAngle :\r\n                                                 p.random(-1000000, 1000000);\r\n}\r\n\r\n/**\r\n * Update the min and max values\r\n * @param  {number} min Minimum value\r\n * @param  {number} max Maximum value\r\n */\r\nSinGenerator.prototype.setBounds = function (min, max) {\r\n    if (min !== undefined) this.min = min;\r\n    if (max !== undefined) this.max = max;\r\n};\r\n\r\n/**\r\n * Update the angle increment (e.g. how fast we move through the sinwave)\r\n * @param  {number} increment New increment value\r\n */\r\nSinGenerator.prototype.setIncrement = function (increment) {\r\n    if (increment !== undefined) this.increment = increment;\r\n};\r\n\r\n/** \r\n * Generate the next value\r\n * @return {number} A value between generators's min and max\r\n */\r\nSinGenerator.prototype.generate = function () {\r\n    this._update();\r\n    var n = this.p.sin(this.angle);\r\n    n = this.p.map(n, -1, 1, this.min, this.max);\r\n    return n;\r\n};\r\n\r\n/**\r\n * Internal update method for generating next value\r\n * @private\r\n */\r\nSinGenerator.prototype._update = function () {\r\n    this.angle += this.increment;\r\n};","require(\"./sketches/noisy-word.js\")();\r\nrequire(\"./sketches/halftone-flashlight-word.js\")();\r\nrequire(\"./sketches/word-particle-wrapping.js\")();\r\nrequire(\"./sketches/fleeing-halftones.js\")();","module.exports = FleeingParticle;\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\n\r\nfunction FleeingParticle(p, color, radius, position, velocity) {\r\n    this.p = p;\r\n    this._pos = position.copy();\r\n    this._initPos = position.copy();\r\n    this._vel = velocity;\r\n    this._color = color;\r\n    this._radius = radius;\r\n    this._noiseGenerator = new Noise.NoiseGenerator1D(p, 0, 1, 0.1);\r\n    this._maxVelocity = 5;\r\n\r\n    this._xMax = this.p.width + this._radius;\r\n    this._xMin = -this._radius;\r\n    this._yMax = this.p.height + this._radius;\r\n    this._yMin = -this._radius;\r\n}\r\n\r\nFleeingParticle.prototype.headTowardsInitial = function () {\r\n    var dx = this._initPos.x - this._pos.x;\r\n    var dy = this._initPos.y - this._pos.y;\r\n    var dist = Math.sqrt(dx * dx + dy * dy);\r\n    var angle = this.p.atan2(dy, dx);\r\n\r\n    var noiseMax = this.p.map(dist, 50, 0, this.p.TWO_PI/2, 0);\r\n    noiseMax = Math.min(noiseMax, this.p.TWO_PI/2);\r\n    var noise = this._noiseGenerator.generate();\r\n    noise = this.p.map(noise, 0, 1, -noiseMax, noiseMax);\r\n    angle += noise;\r\n\r\n    this._vel.x = Math.cos(angle) * Math.min(this._maxVelocity, dist);\r\n    this._vel.y = Math.sin(angle) * Math.min(this._maxVelocity, dist);\r\n};\r\n\r\nFleeingParticle.prototype.avoid = function (x, y) {\r\n    var dx = this._pos.x - x;\r\n    var dy = this._pos.y - y;\r\n    var angle = this.p.atan2(dy, dx);\r\n    var dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    var noiseMax = this.p.map(dist, 0, 50, 0, this.p.TWO_PI/2);\r\n    noiseMax = Math.min(noiseMax, this.p.TWO_PI/2);\r\n    var noise = this._noiseGenerator.generate();\r\n    noise = this.p.map(noise, 0, 1, -noiseMax, noiseMax);\r\n    angle += noise;\r\n\r\n    this._vel.x = Math.cos(angle) * this._maxVelocity;\r\n    this._vel.y = Math.sin(angle) * this._maxVelocity;\r\n};\r\n\r\nFleeingParticle.prototype.update = function () {\r\n    this._pos.add(this._vel);\r\n};\r\n\r\nFleeingParticle.prototype.draw = function () {\r\n    if (this._isOffscreen()) return;\r\n    this.p.push();\r\n        this.p.fill(this._color);\r\n        this.p.noStroke();\r\n        this.p.ellipse(this._pos.x, this._pos.y, this._radius, this._radius);\r\n    this.p.pop();\r\n};\r\n\r\nFleeingParticle.prototype._isOffscreen = function () {\r\n    if (this._pos.x > this._xMax) return true;\r\n    if (this._pos.x < this._xMin) return true;    \r\n    if (this._pos.y > this._yMax) return true;    \r\n    if (this._pos.y < this._yMin) return true;\r\n    return false;\r\n};","module.exports = TextParticle;\r\n\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\n\r\nfunction TextParticle(p, font, fontSize, text, position, velocity) {\r\n    this.p = p;\r\n    this._pos = position;\r\n    this._vel = velocity;\r\n    this._rotation = 0;\r\n    this._bboxText = new BboxText(font, text, fontSize, p);\r\n    this._bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                             BboxText.BASELINE.BOX_CENTER);\r\n\r\n    // Calculate particle bounds\r\n    var bounds = this._bboxText.getBbox(this._pos.x, this._pos.y);\r\n    this.width = bounds.w;\r\n    this.halfWidth = bounds.w / 2;\r\n    this.height = bounds.h;\r\n    this.halfHeight = bounds.h / 2;\r\n\r\n    // Holding on to the offscreen position for when the word is partially \r\n    // offscreen, but not completely offscreen.\r\n    this._wrappedPos = null;\r\n    this._xReflectPos = null;\r\n    this._yReflectPos = null;\r\n}\r\n\r\nTextParticle.prototype.setVelocity = function (velocity) {\r\n    this._vel.x = velocity.x;\r\n    this._vel.y = velocity.y;\r\n};\r\n\r\nTextParticle.prototype.setRotation = function (radians) {\r\n    this._bboxText.setRotation(radians);\r\n};\r\n\r\nTextParticle.prototype.update = function () {\r\n    // Update position\r\n    this._pos.add(this._vel);\r\n\r\n    // If the particle is partially offscreen (but not fully), draw two \r\n    // particles - one that is wrapped around the screen and one that is not.\r\n    this._wrappedPos = this._pos.copy();\r\n    this._xReflectPos = this._pos.copy();\r\n    this._yReflectPos = this._pos.copy();\r\n\r\n    // Calculate the positions of the sides of the particle\r\n    var left = this._pos.x - this.halfWidth;\r\n    var right = this._pos.x + this.halfWidth;\r\n    var top = this._pos.y - this.halfHeight;\r\n    var bottom = this._pos.y + this.halfHeight;\r\n\r\n    var amountOffscreen, distBeyondWrap;\r\n\r\n    // Check if word is offscreen along x-axis\r\n    if (right > this.p.width) {\r\n        amountOffscreen = right - this.p.width;\r\n        if (amountOffscreen > this.width) {\r\n            // Word is completely off the right edge of the screen, so it\r\n            // needs to be wrapped around to the left side of the screen. It is\r\n            // important to account for the \"remainder\" to get smooth motion:\r\n            // (amountOffscreen - this.width) = distance from left edge of word\r\n            //                                  to the right edge of the screen\r\n            distBeyondWrap = (amountOffscreen - this.width);\r\n            this._pos.x = this.halfWidth + distBeyondWrap;\r\n            // If the particle wraps around the y-axis, we want to keep the x\r\n            // position up to date\r\n            this._wrappedPos.x = this._pos.x;\r\n        }\r\n        else {\r\n            // Word is only partially off the right edge of the screen, so the\r\n            // wrappedPos is going to be used. Project what the position of the\r\n            // particle would be if it were wrapped around the left edge of the\r\n            // screen\r\n            this._wrappedPos.x = -this.halfWidth + amountOffscreen;\r\n            this._xReflectPos.x = -this.halfWidth + amountOffscreen;\r\n        }\r\n    }\r\n    else if (left < 0) {\r\n        amountOffscreen = -left;\r\n        if (amountOffscreen > this.width) {\r\n            // Word is completely off the left edge of the screen, so it needs\r\n            // to be wrapped around to the right side of the screen\r\n            distBeyondWrap = (amountOffscreen - this.width);\r\n            this._pos.x = (this.p.width - this.halfWidth) - distBeyondWrap;\r\n            this._wrappedPos.x = this._pos.x;\r\n        }\r\n        else {\r\n            // Word is only partially off the left edge of the screen\r\n            this._wrappedPos.x = (this.p.width + this.halfWidth) - amountOffscreen;\r\n            this._xReflectPos.x = (this.p.width + this.halfWidth) - amountOffscreen;\r\n        }\r\n    }\r\n\r\n    // Check if word is offscreen along y-axis\r\n    if (bottom > this.p.height) {\r\n        amountOffscreen = bottom - this.p.height;\r\n        if (amountOffscreen > this.height) {\r\n            // Word is completely off the bottom edge of the screen, so it\r\n            // needs to be wrapped around to the top side of the screen \r\n            distBeyondWrap = (amountOffscreen - this.height);\r\n            this._pos.y = this.halfHeight + distBeyondWrap;\r\n            // If the particle wraps around the x-axis, we want to keep the y\r\n            // position up to date\r\n            this._wrappedPos.y = this._pos.y;\r\n        }\r\n        else {\r\n            // Word is only partially off the bottom edge of the screen\r\n            this._wrappedPos.y = -this.halfHeight + amountOffscreen;\r\n            this._yReflectPos.y = -this.halfHeight + amountOffscreen;\r\n        }\r\n    }\r\n    else if (top < 0) {\r\n        amountOffscreen = -top;\r\n        if (amountOffscreen > this.height) {\r\n            // Word is completely off the top edge of the screen, so it needs\r\n            // to be wrapped around to the bottom side of the screen\r\n            distBeyondWrap = (amountOffscreen - this.height);\r\n            this._pos.y = (this.p.height - this.halfHeight) - distBeyondWrap;\r\n            this._wrappedPos.y = this._pos.y;\r\n        }\r\n        else {\r\n            // Word is only partially off the top edge of the screen\r\n            this._wrappedPos.y = (this.p.height + this.halfHeight) - amountOffscreen;\r\n            this._yReflectPos.y = (this.p.height + this.halfHeight) - amountOffscreen;\r\n        }\r\n    }\r\n\r\n};\r\n\r\nTextParticle.prototype.draw = function () {\r\n    this._bboxText.draw(this._pos.x, this._pos.y, this._rotation);\r\n\r\n    if (!this._wrappedPos.equals(this._pos)) {\r\n        // wrappedPos has a different value, so the particle is offscreen       \r\n        this._bboxText.draw(this._wrappedPos.x, this._wrappedPos.y, \r\n                            this._rotation);\r\n    }\r\n    \r\n    if (this._xReflectPos.x !== this._pos.x) {        \r\n        this._xReflectPos.y = this._pos.y;\r\n        this._bboxText.draw(this._xReflectPos.x, this._xReflectPos.y,\r\n                            this._rotation);\r\n    }\r\n\r\n    if (this._yReflectPos.y !== this._pos.y) {        \r\n        this._yReflectPos.x = this._pos.x;\r\n        this._bboxText.draw(this._yReflectPos.x, this._yReflectPos.y, \r\n                            this._rotation);\r\n    }\r\n};","module.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\nvar FleeingParticle = require(\"../particles/fleeing-particle.js\");\r\n\r\n// Globals\r\nvar p, font;\r\nvar particles = [];\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"scatter\";\r\nvar fontSize = 140;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \"josefin-slab/JosefinSlab-Bold.ttf\";\r\n\r\nfunction startSketch() { \r\n    // Create div on page for the sketch\r\n    var id = \"fleeing-halftones\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textSize(fontSize);\r\n    bboxText = new BboxText(font, text, fontSize, p);\r\n    bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                       BboxText.BASELINE.FONT_CENTER);\r\n    p.noStroke();\r\n    p.fill(\"#0A000A\");    \r\n    bboxText.draw(p.width / 2, p.height / 2);\r\n\r\n    // Loop over the pixels in the text's bounding box to sample the word\r\n    var bbox = bboxText.getBbox(p.width / 2, p.height / 2);\r\n    var startX = Math.floor(Math.max(bbox.x - 5, 0));\r\n    var endX = Math.ceil(Math.min(bbox.x + bbox.w + 5, p.width));\r\n    var startY = Math.floor(Math.max(bbox.y - 5, 0));\r\n    var endY = Math.ceil(Math.min(bbox.y + bbox.h + 5, p.height));\r\n    var spacing = 5;\r\n    p.loadPixels();\r\n    p.pixelDensity(1);\r\n    circles = [];\r\n    var jitter = p.random.bind(p, -2/3 * spacing, 2/3 * spacing);\r\n    var particleRadius = 8;\r\n    for (var y = startY; y < endY; y += spacing) {\r\n        for (var x = startX; x < endX; x += spacing) {  \r\n            var i = 4 * ((y * p.width) + x);\r\n            var r = p.pixels[i];\r\n            var g = p.pixels[i + 1];\r\n            var b = p.pixels[i + 2];\r\n            var a = p.pixels[i + 3];\r\n            var c = p.color(r, g, b, a);\r\n            if (p.saturation(c) > 0) {\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity(); \r\n                var col = p.color(\"#06FFFF\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity();\r\n                var col = p.color(\"#FE00FE\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n\r\n                var pos = p.createVector(x + jitter(), y + jitter());\r\n                var vel = randomVelocity();\r\n                var col = p.color(\"#FFFF04\");\r\n                var rad = particleRadius + p.random(-3, 1);\r\n                var particle = new FleeingParticle(p, col, rad, \r\n                                                   pos, vel);\r\n                particles.push(particle);\r\n            }\r\n        }\r\n    }\r\n    p.updatePixels();\r\n}\r\n\r\nfunction randomVelocity() {\r\n    var angle = p.random(0, p.TWO_PI);\r\n    var magnitude = p.random(2, 10);\r\n    var velocity = p.createVector(magnitude * Math.cos(angle),\r\n                                  magnitude * Math.sin(angle));\r\n    return velocity;\r\n}\r\n\r\nfunction draw() {\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Clear\r\n    p.blendMode(p.BLEND);\r\n    p.background(255);\r\n\r\n    // Draw \"halftone\" logo\r\n    p.noStroke();   \r\n    p.blendMode(p.MULTIPLY);\r\n    for (var i = 0; i < particles.length; i += 1) {\r\n        var particle = particles[i];\r\n\r\n        if (isMouseOver) particle.avoid(p.mouseX, p.mouseY);\r\n        else particle.headTowardsInitial();\r\n\r\n        particle.update();\r\n        particle.draw();\r\n    }\r\n}","module.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar BboxText = require(\"p5-bbox-aligned-text\");\r\n\r\n// Globals\r\nvar p, font, circles, bboxText;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"halftone\";\r\nvar fontSize = 150;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"theleagueof-league-gothic/leaguegothic-regular-webfont.ttf\";\r\n\r\nfunction startSketch() { \r\n    // Create div on page for the sketch\r\n    var id = \"halftone-flashlight-word\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textSize(fontSize);\r\n    bboxText = new BboxText(font, text, fontSize, p);\r\n    bboxText.setAnchor(BboxText.ALIGN.BOX_CENTER, \r\n                       BboxText.BASELINE.FONT_CENTER);\r\n    p.noStroke();\r\n    p.fill(\"#0A000A\");    \r\n    bboxText.draw(p.width / 2, p.height / 2);\r\n\r\n\r\n    // Loop over the pixels in the text's bounding box to sample the word\r\n    var bbox = bboxText.getBbox(p.width / 2, p.height / 2);\r\n    var startX = Math.floor(Math.max(bbox.x - 5, 0));\r\n    var endX = Math.ceil(Math.min(bbox.x + bbox.w + 5, p.width));\r\n    var startY = Math.floor(Math.max(bbox.y - 5, 0));\r\n    var endY = Math.ceil(Math.min(bbox.y + bbox.h + 5, p.height));\r\n    var spacing = 5;\r\n    p.loadPixels();\r\n    p.pixelDensity(1);\r\n    circles = [];\r\n    for (var y = startY; y < endY; y += spacing) {\r\n        for (var x = startX; x < endX; x += spacing) {  \r\n            var i = 4 * ((y * p.width) + x);\r\n            var r = p.pixels[i];\r\n            var g = p.pixels[i + 1];\r\n            var b = p.pixels[i + 2];\r\n            var a = p.pixels[i + 3];\r\n            var c = p.color(r, g, b, a);\r\n            if (p.saturation(c) > 0) {\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#06FFFF\")\r\n                });\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#FE00FE\")\r\n                });\r\n                circles.push({\r\n                    x: x + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    y: y + p.random(-2/3 * spacing, 2/3 * spacing),\r\n                    color: p.color(\"#FFFF04\")\r\n                });\r\n            }\r\n        }\r\n    }\r\n    p.updatePixels();\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Clear\r\n    p.blendMode(p.BLEND);\r\n    p.background(255);\r\n\r\n    // Draw \"halftone\" logo\r\n    p.noStroke();   \r\n    p.blendMode(p.MULTIPLY);\r\n    for (var i = 0; i < circles.length; i += 1) {\r\n        var circle = circles[i];\r\n        var c = circle.color;\r\n        var dist = p.dist(circle.x, circle.y, p.mouseX, p.mouseY);\r\n        var radius = p.map(dist, 0, 150, 1, 10);\r\n        p.fill(c);\r\n        p.ellipse(circle.x, circle.y, radius, radius);\r\n    }\r\n}","module.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\n\r\n// Globals\r\nvar p, font, rotationNoise, xyNoise;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"Squiggle\";\r\nvar fontSize = 100;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"theleagueof-league-gothic/leaguegothic-regular-webfont.ttf\";\r\n\r\nfunction startSketch() {    \r\n    // Create div on page for the sketch\r\n    var id = \"noisy-word\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textFont(font);\r\n    p.textSize(fontSize);\r\n    p.textAlign(p.CENTER, p.CENTER);\r\n    p.stroke(255);\r\n    p.fill(\"#0A000A\");\r\n    p.strokeWeight(2);      \r\n    p.text(text, p.width / 2, p.height / 2);\r\n\r\n    // Set up noise generators\r\n    rotationNoise = new Noise.NoiseGenerator1D(p, -p.PI/4, p.PI/4, 0.02); \r\n    xyNoise = new Noise.NoiseGenerator2D(p, -100, 100, -50, 50, 0.01, 0.01);\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Calculate position and rotation to create a jittery logo\r\n    var rotation = rotationNoise.generate();\r\n    var xyOffset = xyNoise.generate();\r\n\r\n    // Draw the logo\r\n    p.push();\r\n        p.translate(p.width / 2 + xyOffset.x, p.height / 2 + xyOffset.y);\r\n        p.rotate(rotation);\r\n        p.text(text, 0, 0);\r\n    p.pop();\r\n}","module.exports = startSketch;\r\n\r\n// Modules\r\nvar dom = require(\"../utilities/dom-utilities.js\");\r\nvar Noise = require(\"../generators/noise-generators.js\");\r\nvar SinGenerator = require(\"../generators/sin-generator.js\");\r\nvar TextParticle = require(\"../particles/text-particle.js\");\r\n\r\n// Globals\r\nvar p, font, textParticle, rotationGenerator, sinGenerator;\r\nvar isFirstFrame = true;\r\nvar isMouseOver = false;\r\nvar canvasSize = {\r\n    width: 400,\r\n    height: 150\r\n};\r\nvar text = \"Ripple\";\r\nvar fontSize = 50;\r\nvar fontsFolder = \"./assets/fonts/\";\r\nvar fontPath = fontsFolder + \r\n               \"league-spartan/leaguespartan-bold.ttf\";\r\n\r\nfunction startSketch() {    \r\n    // Create div on page for the sketch\r\n    var id = \"word-particle-wrapping\";\r\n    var sketchesContainer = document.getElementById(\"sketches\");\r\n    var sketchDiv = dom.createElement(\"div\", {id: id}, sketchesContainer);\r\n\r\n    // Create a p5 instance inside of the ID specified\r\n    new p5(function (_p) {\r\n        p = _p;\r\n        p.preload = preload;\r\n        p.setup = setup;\r\n        p.draw = draw;\r\n    }, id); \r\n}\r\n\r\nfunction preload() {\r\n    // Load the font into a global - this way we can ask the font for a bbox\r\n    font = p.loadFont(fontPath);\r\n}\r\n\r\nfunction setup() {\r\n    var renderer = p.createCanvas(canvasSize.width, canvasSize.height);\r\n\r\n    // There isn't a good way to check whether the sketch has the mouse over\r\n    // it. p.mouseX & p.mouseY are initialized to (0, 0), and p.focused isn't \r\n    // always reliable.\r\n    renderer.canvas.addEventListener(\"mouseover\", function () {\r\n        isMouseOver = true;\r\n    });\r\n    renderer.canvas.addEventListener(\"mouseout\", function () {\r\n        isMouseOver = false;\r\n    });\r\n\r\n    // Draw the stationary text\r\n    p.background(255);\r\n    p.textFont(font);\r\n    p.textSize(fontSize);\r\n    p.textAlign(p.CENTER, p.CENTER);\r\n    p.stroke(255);\r\n    p.fill(\"#00ACE0\");\r\n    p.strokeWeight(2);      \r\n    p.text(text, p.width / 2, p.height / 2);\r\n\r\n    // Create the word particle\r\n    var pos = p.createVector(p.width / 2, p.height / 2);\r\n    var vel = p.createVector(3, -1); \r\n    textParticle = new TextParticle(p, font, fontSize, text, pos, vel);\r\n\r\n    rotationGenerator = new SinGenerator(p, -Math.PI/5, Math.PI/5, 0.06);\r\n    directionGenerator = new Noise.NoiseGenerator1D(p, 0, p.TWO_PI, 0.005);\r\n}\r\n\r\nfunction draw() {\r\n    // No need to do anything if the mouse isn't over the sketch\r\n    if (!isMouseOver) return;\r\n\r\n    // When the text is about to become active for the first time, clear\r\n    // the stationary logo that was drawn during setup. \r\n    if (isFirstFrame) {\r\n        p.background(255);\r\n        isFirstFrame = false;\r\n    }\r\n\r\n    // Update the particles velocity and rotation\r\n    var angle = directionGenerator.generate();\r\n    textParticle.setVelocity({x: p.cos(angle) * 1.25, y: p.sin(angle) * 1.25});\r\n    var rotation = rotationGenerator.generate();\r\n    textParticle.setRotation(rotation);\r\n    textParticle.update();\r\n\r\n    // Draw the particle\r\n    p.fill(\"#00ACE0\");\r\n    p.stroke(255);\r\n    p.strokeWeight(1);\r\n    textParticle.draw();\r\n}","module.exports.forEachInObject = function (object, iterationFunction) {\r\n\tif (!object) return;\r\n\tfor (var key in object) {\r\n\t\tif (!object.hasOwnProperty(key)) continue;\r\n\t\titerationFunction(key, object[key], object);\r\n\t}\r\n};\r\n\r\nmodule.exports.createElement = function (tagName, parameters, parent) {\r\n\tvar el = document.createElement(tagName);\r\n\tif (parameters) {\r\n\t\tif (parameters.textContent) el.textContent = parameters.textContent;\r\n\t\tif (parameters.id) el.id = parameters.id;\r\n\t\tif (parameters.className) el.className = parameters.className;\r\n\t\tif (parameters.style) addStyle(el, parameters.style);\r\n\t\tif (parameters.attributes) addAttributes(el, parameters.attributes);\r\n\t}\t\r\n\tif (parent) parent.appendChild(el);\r\n\treturn el;\r\n};\r\n\r\nmodule.exports.addStyle = function (element, style) {\r\n\tif (!style) return;\r\n\tforEachInObject(style, function (key, val) {\r\n\t\telement.style[key] = val;\r\n\t});\t\r\n};\r\n\r\nmodule.exports.addAttributes = function (element, attributes) {\r\n\tif (!attributes) return;\r\n\tforEachInObject(attributes, function (key, val) {\r\n\t\telement[key] = val;\r\n\t});\t\r\n};\r\n\r\nmodule.exports.removeElement = function (element) {\r\n\telement.parentElement.removeChild(element);\r\n};"],"sourceRoot":"/source/"}